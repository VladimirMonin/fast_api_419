## Урок 1: Основы FastAPI и сила типизации

### **1. Введение: Почему FastAPI?**

1.1. **Крючок:** Начать с аналогии. Спросить аудиторию: "Представьте, что вы строите современный небоскреб, но у вас из инструментов только ручная дрель и молоток. Можно ли построить? Да. Будет ли это эффективно? Нет." Традиционные синхронные фреймворки (как Flask/Django в их базовой конфигурации) — это и есть тот самый молоток. Они надежны, но не всегда эффективны для современных задач с тысячами одновременных подключений.
1.2. **Проблема I/O-bound операций:** Объяснить простым языком, что такое I/O-bound задача (запрос к базе данных, обращение к другому API, чтение файла). В это время процессор "простаивает". В синхронном мире один рабочий процесс будет ждать ответа, блокируя обработку других запросов.
1.3. **Решение FastAPI:** Представить FastAPI как "электрический шуруповерт" в нашей аналогии. Он построен на **асинхронности** (благодаря ASGI-серверам и библиотеке Starlette). Пока FastAPI ждет ответа от базы данных по одному запросу, он не блокируется, а может обрабатывать десятки других. Это дает колоссальный прирост производительности именно в I/O-bound задачах.

******

### **2. Первое приложение "Hello, World"**

2.1. **Цель блока:** Показать, как быстро можно запустить рабочий веб-сервер. От идеи до работающего эндпоинта за 2 минуты.
2.2. **Задача для Инженера Кода:** Нужно предоставить команды для терминала и код.
\* **Установка:** `pip install fastapi "uvicorn[standard]"`
\* **Код (`main.py`):**
\`\`\`python
from fastapi import FastAPI

````
    app = FastAPI()

    @app.get("/")
    async def read_root():
        return {"Hello": "World"}
    ```
````

2.3. **Объяснение для Педагога:**
\* `app = FastAPI()`: Это создание "мозга" нашего приложения.
\* `@app.get("/")`: Это "декоратор операции пути". Мы говорим FastAPI: "Когда кто-то делает `GET`-запрос на главный URL (`/`), выполни функцию ниже".
\* `async def`: Подчеркнуть, что FastAPI "думает" асинхронно. Даже если функция простая, использование `async` — хорошая практика.
2.4. **Запуск сервера:** Показать команду `uvicorn main:app --reload`. Объяснить каждую часть:
\* `main`: Файл `main.py`.
\* `:app`: Объект `app` внутри файла.
\* `--reload`: Флаг для автоматической перезагрузки сервера при изменении кода — крайне удобно при разработке.
\* **Результат:** Открыть в браузере `http://127.0.0.1:8000` и увидеть JSON `{"Hello": "World"}`.

******

### **3. Сила Pydantic: строгая типизация на бэкенде**

3.1. **Ключевая идея:** На бэкенд, как и на фронтенд, приходят данные. И мы должны быть уверены в их структуре и типах. Pydantic — это инструмент, который определяет "контракт" или "форму" для наших данных.
3.2. **Создание первой модели:** Взять за основу сущность "Товар" из фронтенда.
\* **Задача для Инженера Кода:** Написать Pydantic-модель в `main.py`.
\`\`\`python
from pydantic import BaseModel
from typing import Optional

````
    class Product(BaseModel):
        id: int
        name: str
        description: Optional[str] = None # Поле может отсутствовать
        price: float
    ```
````

3.3. **Преимущества (тезисно):**
\* **Надежность:** Код становится предсказуемым. Мы всегда знаем, какие поля есть у товара и какого они типа.
\* **Автоматическая валидация:** FastAPI будет автоматически проверять все входящие запросы на соответствие этой модели.
\* **Автодокументация:** Главная "магия". FastAPI использует эти модели для создания интерактивной документации.
******

### **4. Практика: Валидация данных "на лету"**

4.1. **Цель блока:** Не просто рассказать, а наглядно показать "магию" FastAPI и Pydantic в действии.
4.2. **Задача для Инженера Кода:** Добавить новый `POST`-эндпоинт в `main.py`.
` python @app.post("/products/") async def create_product(product: Product): return product `
\* **Объяснение для Педагога:** Показать, что мы просто указали в аннотации типа `product: Product`, и FastAPI сам поймет, что нужно взять тело `POST`-запроса, проверить его по модели `Product` и передать в нашу функцию.

******

4.3. **Интерактивная демонстрация:**
\* Отправить студентов на URL `http://127.0.0.1:8000/docs`. Это Swagger UI.
\* Показать, что там уже появился наш `POST /products/` эндпоинт, и в схеме запроса четко описана структура `Product` с типами полей.
\* Используя интерфейс Swagger, отправить **корректный** JSON. Показать, что сервер отвечает `200 OK` и возвращает тот же JSON.
\* Затем отправить **некорректный** JSON (например, `"price": "дешево"`). Показать, как FastAPI автоматически возвращает ошибку `422 Unprocessable Entity` с подробным описанием, что именно и где пошло не так.
4.4. **Связь с домашним заданием:** Подвести итог: "Сегодня мы научились создавать эндпоинты и описывать модели данных. Вашим домашним заданием будет по аналогии создать Pydantic-модели для "Товара" и "Категории" и реализовать эндпоинт, который принимает и возвращает модель товара, чтобы вы сами прочувствовали эту автоматическую валидацию".

******

## Урок 2: Построение API и маршрутизация с APIRouter

### **1. Проблема роста: Один файл — это хаос**

1.1. **Аналогия:** Начать с аналогии рабочего стола. Наш `main.py` из первого урока — это как рабочий стол, на который мы свалили все документы. Пока их два-три — все в порядке. Но что будет, когда их станет 50? Нам нужны папки.
1.2. **Визуализация проблемы:** Попросить студентов представить, что кроме товаров, нам нужно добавить в `main.py` CRUD для категорий, пользователей, заказов, корзин... Файл разрастется до сотен строк, и найти что-то станет невозможно. Это называется "технический долг", и мы должны избегать его с самого начала.

******

### **2. Решение: `APIRouter` для порядка**

2.1. **Ключевая концепция:** `APIRouter` — это и есть наши "папки". Мы создаем отдельный Python-файл для каждой сущности (например, `products.py`), объявляем в нем роутер и складываем туда все пути, связанные только с товарами. Затем главный файл (`main.py`) просто "импортирует" эту папку.
2.2. **Задача для Инженера Кода:** Провести рефакторинг проекта.
\* **Новая структура:**
`/my_project ├── /app │   ├── __init__.py │   ├── main.py │   └── /routers │       ├── __init__.py │       └── products.py └── ...`
\* **Код для `app/routers/products.py`:**
\`\`\`python
from fastapi import APIRouter

````
  router = APIRouter()
  
  # Все эндпоинты, связанные с товарами, будут здесь
  # Например, тот, что мы создали на прошлом уроке
  @router.post("/")
  async def create_product(product: Product): # Product - модель Pydantic из прошлого урока
      return product
  ```
* **Код для `app/main.py`:**
  ```python
  from fastapi import FastAPI
  from .routers import products
  
  app = FastAPI()
  
  # "Подключаем" папку с роутами товаров
  app.include_router(
      products.router,
      prefix="/products", # Все URL в этом роутере будут начинаться с /products
      tags=["Products"]    # Группировка в документации /docs
  )
  ```
````

2.3. **Объяснение для Педагога:** Сделать акцент на `prefix` и `tags` в `app.include_router`. `prefix` избавляет нас от необходимости писать `/products` в каждом URL внутри `products.py`. `tags` создает красивую группировку в авто-документации.

******

### **3. Практика: Реализация полного CRUD для товаров**

3.1. **Создание "In-memory" базы данных:** Прямо в файле `app/routers/products.py` создаем глобальную переменную — список, который будет имитировать нашу базу данных.
\* **Задача для Инженера Кода:**
\`\`\`python
\# app/routers/products.py
from typing import List
\# ... импорты Product, APIRouter ...

````
  # Наша временная база данных
  db_products: List[Product] = [
      Product(id=1, name="Плюмбус", price=10.5),
      Product(id=2, name="Коробка с Мисиксами", price=25.0)
  ]
  ```
````

******

3.2. **Реализация эндпоинтов (в `app/routers/products.py`):**
\* **Read All (`GET /`):**
` python @router.get("/", response_model=List[Product]) async def get_all_products(): return db_products `
\* **Read One (`GET /{product_id}`):**
\* **Концепция:** Познакомить с **Path-параметрами**.
` python @router.get("/{product_id}", response_model=Product) async def get_product(product_id: int): # Здесь будет логика поиска, пока без обработки ошибок for p in db_products: if p.id == product_id: return p # Что если не нашли? Разберем в следующем блоке. `
\* **Create (`POST /`):** Немного доработать, чтобы ID генерировался автоматически.
\* **Update (`PUT /{product_id}`):** Показать, как эндпоинт может принимать и Path-параметр, и тело запроса.
\* **Delete (`DELETE /{product_id}`):** Принять Path-параметр и удалить элемент из списка `db_products`.

******

### **4. Обработка ошибок: `HTTPException`**

4.1. **Сценарий:** Запустить код эндпоинта `get_product` и запросить в браузере `/products/999`. Сервер вернет ошибку `500 Internal Server Error`, потому что функция ничего не вернула (или упала). Это плохо. Клиент должен получить осмысленную ошибку.
4.2. **Решение:** Познакомить с `HTTPException` — стандартным способом FastAPI "выбрасывать" ошибки с нужным HTTP-статусом.
4.3. **Задача для Инженера Кода:** Доработать эндпоинт `get_product`.
` python from fastapi import HTTPException # ... @router.get("/{product_id}", response_model=Product) async def get_product(product_id: int): for p in db_products: if p.id == product_id: return p raise HTTPException(status_code=404, detail="Product not found") `

******

4.4. **Демонстрация:** Повторно запросить `/products/999`. Показать, что теперь сервер корректно отвечает статусом **404 Not Found** и возвращает JSON `{"detail": "Product not found"}`. Объяснить, что именно такой ответ ждет frontend-приложение для обработки сценария "Товар не найден".
4.5. **Связь с домашним заданием:** "Мы только что реализовали полный CRUD для товаров. Ваша задача — по аналогии создать новый роутер для категорий (`categories.py`) и реализовать для них такой же полный CRUD, пока что тоже сохраняя данные в простом списке".

******

## Урок 3: Подключение к базе данных и ORM с SQLAlchemy'

### **1. Проблема: Наши данные — однодневки**

1.1. **Практическая демонстрация:** Начать урок с живого примера.
\* Запустить сервер из Урока 2.
\* Через `/docs` добавить новый товар с помощью `POST /products`.
\* Сделать `GET /products` и показать, что новый товар в списке.
\* Остановить `uvicorn` в терминале (Ctrl+C) и запустить его снова.
\* Сделать еще один `GET /products` и показать, что новый товар **исчез**.
1.2. **Вывод:** Наглядно подвести итог. Переменная в Python — это **волатильная (непостоянная) память**. Чтобы данные пережили перезапуск сервера, их нужно хранить в **постоянном хранилище**, то есть в базе данных.

******

### **2. Знакомство с ORM и SQLAlchemy**

2.1. **Аналогия "Переводчик":** Объяснить концепцию ORM. "Наше приложение говорит на языке Python. База данных PostgreSQL — на языке SQL. Напрямую они друг друга не понимают. **ORM** (в нашем случае **SQLAlchemy**) — это гениальный переводчик, который стоит между ними. Мы пишем Python-код (`product.price = 99.9`), а ORM на лету переводит это в SQL-команду (`UPDATE products SET price = 99.9 WHERE id = 1`) и наоборот".
2.2. **Две части SQLAlchemy:** Кратко упомянуть, что мы будем использовать:
\* **SQLAlchemy Core:** "Движок" переводчика, который умеет общаться с разными диалектами SQL.
\* **SQLAlchemy ORM:** "Словарь" для переводчика, который связывает наши Python-классы с таблицами в базе данных.
2.3. **Асинхронность:** Подчеркнуть, что мы будем использовать современную, асинхронную версию SQLAlchemy, которая идеально работает в связке с асинхронной природой FastAPI. Для этого нам понадобится специальный драйвер базы данных.

******

### **3. Настройка подключения**

3.1. **Установка зависимостей:**
\* **Задача для Инженера Кода:** Выполнить в терминале установку SQLAlchemy и драйвера для PostgreSQL.
` bash pip install sqlalchemy asyncpg `
3.2. **Файл конфигурации:** Подчеркнуть, что данные для подключения (пароли, адреса) никогда не должны быть зашиты в коде.
\* **Задача для Инженера Кода:** Создать новый файл `app/config.py`.
` python # app/config.py # Формат: postgresql+asyncpg://<user>:<password>@<host>:<port>/<dbname> DATABASE_URL = "postgresql+asyncpg://postgres:mysecretpassword@localhost:5432/store_db" `
Педагог должен объяснить каждую часть этой строки.
3.3. **Создание "Движка" и "Фабрики сессий":**
\* **Задача для Инженера Кода:** Создать новый файл `app/database.py` для всей логики, связанной с БД.
\`\`\`python
\# app/database.py
from sqlalchemy.ext.asyncio import create\_async\_engine, async\_sessionmaker
from .config import DATABASE\_URL

````
  # Создаем асинхронный "движок" для подключения к БД
  engine = create_async_engine(DATABASE_URL, echo=True)

  # Создаем "фабрику", которая будет производить сессии для каждого запроса
  async_session_factory = async_sessionmaker(engine, expire_on_commit=False)
  ```
* **Объяснение для Педагога:**
    * `engine`: Главный объект для связи с БД. `echo=True` — очень полезный флаг для разработки, он будет выводить в консоль все SQL-запросы, которые генерирует SQLAlchemy.
    * `async_session_factory`: Это не сама сессия, а "станок", который будет создавать новые сессии по нашему запросу.
````

******

### **4. Система зависимостей FastAPI (`Depends`)**

4.1. **Проблема:** Для каждого запроса к API нам нужен **один** сеанс работы с БД. Его нужно: 1) Открыть -\> 2) Использовать -\> 3) Закрыть. Писать эту логику в каждом эндпоинте — долго, скучно и можно легко ошибиться.
4.2. **Решение:** Мы напишем одну функцию, которая управляет жизненным циклом сессии, а FastAPI будет автоматически вызывать ее для каждого эндпоинта, который в ней нуждается. Это и есть **Dependency Injection (Внедрение зависимостей)**.
4.3. **Задача для Инженера Кода:** Дополнить файл `app/database.py` функцией-зависимостью.
\`\`\`python
\# app/database.py
\# ... предыдущий код ...

````
async def get_db_session():
    # Создаем сессию с помощью нашей фабрики
    async with async_session_factory() as session:
        try:
            yield session
        finally:
            # Гарантированно закрываем сессию после использования
            await session.close()
```
* **Объяснение для Педагога:** Объяснить, как работает `yield`. Код до `yield` выполняется до эндпоинта. `yield` "передает" сессию в эндпоинт. Код в блоке `finally` выполняется после эндпоинта, гарантируя закрытие сессии.
````

******
4.4. **Пример использования:** Показать, как "запросить" эту зависимость в роутере товаров.
\* **Задача для Инженера Кода:** Изменить эндпоинт в `app/routers/products.py`.
\`\`\`python
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get\_db\_session \# Импортируем нашу зависимость

````
  router = APIRouter()

  @router.get("/")
  async def get_all_products(db: AsyncSession = Depends(get_db_session)):
      # Внутри переменной `db` теперь находится готовая к работе сессия БД!
      # Мы пока ничего с ней не делаем, но она доступна.
      return {"message": "Успешное подключение к сессии БД!"}
  ```
````

4.5. **Связь с домашним заданием:** "Сегодня мы настроили подключение к настоящей базе данных. Ваша задача — создать у себя локально базу данных PostgreSQL, прописать корректные данные в `DATABASE_URL` и запустить приложение. Убедитесь, что при запросе к эндпоинту `/products/` вы не получаете ошибок, а в консоли видите SQL-логи от `echo=True`. Это подготовит нас к следующему уроку, где мы будем создавать таблицы и сохранять в них данные".

******

## Урок 4: Работа с данными в базе и отношения между таблицами

### **1. От Pydantic-схем к SQLAlchemy-моделям**

1.1. **Ключевое различие (Аналогия):** Использовать аналогию для четкого разделения.
\* **Pydantic-схема** — это **таможенная декларация** на границе вашего API. Она описывает, какие "товары" (данные) и в каком виде могут пересечь границу (войти в запрос или выйти в ответе).
\* **SQLAlchemy-модель** — это **чертеж склада** (таблицы в БД), где эти товары будут храниться. Чертеж описывает "стеллажи" (колонки), их тип и правила размещения.
\* Они очень похожи, но служат разным целям.
1.2. **Задача для Инженера Кода:** Создать новый файл `app/models.py` для описания "чертежей склада".
\`\`\`python
\# app/models.py
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped\_column
from sqlalchemy import String, Text

````
# Базовый класс для всех наших моделей, от которого они будут наследоваться
class Base(DeclarativeBase):
    pass

# SQLAlchemy-модель для таблицы "products"
class Product(Base):
    __tablename__ = "products"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100), index=True)
    description: Mapped[str | None] = mapped_column(Text) # Используем Text для длинных описаний
    price: Mapped[float]
```
````

******

1.3. **Объяснение для Педагога:** Объяснить каждый элемент:
\* `Base`: Общий "фундамент" для всех моделей.
\* `__tablename__`: Прямое указание имени таблицы в базе данных.
\* `Mapped[...]` и `mapped_column(...)`: Современный синтаксис SQLAlchemy для описания колонок и их типов в Python.
\* `primary_key=True`: Указывает на уникальный идентификатор записи.
\* `index=True`: Создает индекс для быстрого поиска по этому полю.

******

### **2. Создание таблиц**

2.1. **Концепция:** Наши модели в `models.py` — это пока что просто Python-код. Нам нужно выполнить команду, которая по этим "чертежам" построит реальные "склады" (таблицы) в базе данных PostgreSQL.
2.2. **Задача для Инженера Кода:** Создать в корне проекта небольшой отдельный скрипт `create_tables.py` для этой задачи.
\`\`\`python
\# create\_tables.py
import asyncio
from app.database import engine
from app.models import Base

````
async def create_db_and_tables():
    async with engine.begin() as conn:
        # Удаляем все таблицы (для удобства при перезапуске)
        await conn.run_sync(Base.metadata.drop_all)
        # Создаем все таблицы на основе моделей, унаследованных от Base
        await conn.run_sync(Base.metadata.create_all)
    print("Таблицы успешно созданы.")

if __name__ == "__main__":
    asyncio.run(create_db_and_tables())
```
````

******

2.3. **Демонстрация:** Педагог должен запустить в терминале `python create_tables.py`. После этого, используя любой GUI-клиент для баз данных (DBeaver, pgAdmin), подключиться к БД и **наглядно показать** студентам созданную таблицу `products` со всеми колонками. (Рассказать как на примере pgAdmin ЭТО Сделать пошагово)

******

### **3. Переписываем CRUD с использованием SQLAlchemy**

3.1. **Цель:** Выбросить "in-memory" список из `app/routers/products.py` и заменить всю логику на реальные асинхронные запросы к базе данных.
3.2. **Задача для Инженера Кода:** Модифицировать эндпоинты в роутере товаров. Понадобится импортировать `select` из `sqlalchemy`.
\* **Create (`POST /`):**
` python @router.post("/") async def create_product(product_schema: ProductCreateSchema, db: AsyncSession = Depends(get_db_session)): # Создаем экземпляр модели SQLAlchemy на основе данных из Pydantic-схемы new_product = Product(**product_schema.model_dump()) db.add(new_product)       # Добавляем в сессию await db.commit()         # Сохраняем в БД await db.refresh(new_product) # Обновляем объект new_product данными из БД (например, id) return new_product `
\* **Read All (`GET /`):**
` python @router.get("/") async def get_all_products(db: AsyncSession = Depends(get_db_session)): query = select(Product) result = await db.execute(query) products = result.scalars().all() return products `
\* **Read One (`GET /{product_id}`):**
` python @router.get("/{product_id}") async def get_product(product_id: int, db: AsyncSession = Depends(get_db_session)): product = await db.get(Product, product_id) # Удобный метод для поиска по primary key if not product: raise HTTPException(status_code=404, detail="Product not found") return product `

******

3.3. **Объяснение для Педагога:** Детально разобрать жизненный цикл сессии: `db.add()` (пометить для добавления), `db.commit()` (зафиксировать транзакцию), `db.refresh()` (получить актуальное состояние из БД).

******

### **4. Связывание таблиц: Отношения**

4.1. **Концепция:** Товары не существуют в вакууме, они принадлежат категориям.
\* `ForeignKey` (внешний ключ) — это как "записать ID категории на ценнике товара". Это связь на уровне структуры БД.
\* `relationship` (отношение) — это "магия" SQLAlchemy, которая позволяет, имея объект товара, легко получить доступ ко всему объекту связанной категории (`my_product.category.name`), а не просто к её ID.
4.2. **Задача для Инженера Кода:** Дополнить `app/models.py`.
\`\`\`python
\# app/models.py
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

````
class Category(Base):
    __tablename__ = "categories"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True)
    # Обратная связь: из категории можно будет получить все ее товары
    products: Mapped[list["Product"]] = relationship(back_populates="category")

class Product(Base):
    # ... (существующие поля)
    category_id: Mapped[int | None] = mapped_column(ForeignKey("categories.id"))
    # Связь: из товара можно будет получить его категорию
    category: Mapped["Category"] = relationship(back_populates="products")
```
````

******
4.3. **Объяснение для Педагога:** Объяснить, что `ForeignKey("categories.id")` — это инструкция для БД, а `relationship` с `back_populates` создает удобную двустороннюю навигацию в Python-коде.
4.4. **Связь с домашним заданием:** "Мы полностью перевели CRUD товаров на базу данных. Ваша задача — по аналогии реализовать полный CRUD для созданной нами сущности `Category`. А также доработать эндпоинт создания товара, чтобы он принимал `category_id` и корректно связывал новый товар с существующей категорией".

******

## Урок 5: Структура проекта и миграции Базы Данных и Alembic

### **1. Рефакторинг: Профессиональная структура проекта**

1.1. **Цель:** Объяснить принцип **"Разделения ответственности" (Separation of Concerns)**. Роутер не должен знать, как писать в БД. Его задача — принимать HTTP-запросы и отдавать ответы. Функции для работы с БД должны жить отдельно. Это делает код чище, проще для тестирования и поддержки.
1.2. **Новая структура проекта (Задача для Инженера Кода):** Показать целевую структуру папок и файлов.
`/app ├── __init__.py ├── crud.py          # (Слой доступа к данным) - Вся логика работы с БД. ├── database.py      # Настройка подключения. ├── main.py          # Главный файл приложения. ├── models.py        # (Слой БД) - SQLAlchemy-модели. ├── schemas.py       # (Слой API) - Pydantic-схемы. └── /routers ├── __init__.py └── products.py  # (Слой API) - Только эндпоинты.`

******

1.3. **Перенос кода (Задача для Инженера Кода):** Пошагово провести рефакторинг.
\* **Шаг 1: Создать `app/schemas.py`**. Перенести в него все Pydantic-модели. Разделить их по назначению: `ProductBase`, `ProductCreate` (для создания), `ProductUpdate`, `Product` (для чтения из БД).
\* **Шаг 2: Создать `app/crud.py`**. Создать в нем функции для каждой операции с БД. Эти функции принимают сессию `db` и Pydantic-схемы, а внутри работают с SQLAlchemy-моделями.
\`\`\`python
\# app/crud.py
from sqlalchemy.ext.asyncio import AsyncSession
from . import models, schemas

````
    async def get_product(db: AsyncSession, product_id: int):
        return await db.get(models.Product, product_id)

    async def create_product(db: AsyncSession, product: schemas.ProductCreate):
        db_product = models.Product(**product.model_dump())
        db.add(db_product)
        await db.commit()
        await db.refresh(db_product)
        return db_product
    ```
* **Шаг 3: Очистить `app/routers/products.py`**. Удалить из эндпоинтов всю логику работы с `db.add`, `select` и т.д. Вместо этого — импортировать и вызывать функции из `crud.py`. Роутер становится очень "тонким" и читаемым.
    ```python
    # app/routers/products.py
    from .. import crud, schemas

    @router.post("/", response_model=schemas.Product)
    async def create_product_endpoint(product: schemas.ProductCreate, db: AsyncSession = Depends(get_db_session)):
        return await crud.create_product(db=db, product=product)
    ```
````

******

### **2. Проблема: Что делать, если модель изменилась?**

2.1. **Постановка проблемы:** Создать реалистичный сценарий. "Заказчик хочет, чтобы у каждого товара был флаг `is_active`, чтобы временно скрывать товары с сайта, не удаляя их. Нам нужно добавить в таблицу `products` новую колонку `is_active` типа `boolean`".
2.2. **Неправильное решение:** Задать вопрос аудитории: "Мы можем просто добавить поле в `models.py`. Но что дальше? Если мы снова запустим наш скрипт `create_tables.py`, он вызовет `drop_all` и **сотрет все товары, которые мы уже добавили в базу**\! В реальном проекте это катастрофа".

******

### **3. Решение: Alembic — Git для вашей базы данных**

3.1. **Аналогия "Git для БД":** Провести прямые параллели, чтобы сделать концепцию интуитивно понятной.
\* `git commit` ⇔ `alembic revision` (зафиксировать изменения в схеме).
\* `git push` ⇔ `alembic upgrade` (применить изменения к базе данных).
\* `git log` ⇔ `alembic history` (посмотреть историю всех миграций).
\* `git checkout <hash>` ⇔ `alembic downgrade <hash>` (откатиться к старой версии схемы).
3.2. **Установка и инициализация (Задача для Инженера Кода):**
\* **Команда 1:** `pip install alembic`
\* **Команда 2 (в корне проекта):** `alembic init alembic`. Показать, что эта команда создала папку `alembic` и файл `alembic.ini`.

******

### **4. Практика: Проводим первую миграцию**

4.1. **Конфигурация Alembic:** Это самый важный шаг настройки.
\* **В `alembic.ini`:** Найти строку `sqlalchemy.url` и прописать туда путь к нашей БД (можно импортировать из `app.config`).
\* **В `alembic/env.py`:** Сказать Alembic, где искать наши SQLAlchemy-модели.
` python # alembic/env.py # ... from app.models import Base # Импортировать нашу базовую модель target_metadata = Base.metadata # Указать ее как цель для автогенерации # ... `
4.2. **Генерация миграции (Задача для Инженера Кода):**
\* **Шаг 1: Изменить `app/models.py`**. Добавить новое поле в модель `Product`: `is_active: Mapped[bool] = mapped_column(server_default="true")`.
\* **Шаг 2: Выполнить команду в терминале:** `alembic revision --autogenerate -m "Add is_active field to Product"`

******

4.3. **Анализ скрипта миграции:** Открыть новый файл в `alembic/versions/`. Показать студентам функции `upgrade()` и `downgrade()`. Объяснить, что `upgrade` применяет изменения (`op.add_column(...)`), а `downgrade` — откатывает их (`op.drop_column(...)`).
4.4. **Применение миграции (Задача для Инженера Кода):**
\* **Команда:** `alembic upgrade head`. Эта команда выполнит функцию `upgrade` в последней созданной миграции.
4.5. **Проверка результата ("Момент истины"):** Педагог **обязан** открыть GUI-клиент для БД, показать таблицу `products` и то, что в ней появилась новая колонка `is_active`, а все старые записи остались нетронутыми.
4.6. **Связь с домашним заданием:** "Мы навели порядок в проекте и освоили главный инструмент для работы со схемой БД. Ваша задача — реорганизовать свой код по новому образцу (schemas, crud, models). После этого добавьте в модель `Category` новое поле `description: Mapped[str | None]` и примените это изменение, сгенерировав и выполнив свою первую Alembic-миграцию".

******

Принято. План утвержден.

## Урок 6: Интеграция с React и CORS - решение проблем с политикой одного источника

### **1. Два сервера: Постановка задачи**

1.1. **Практическая демонстрация:** Педагог должен открыть два терминала и запустить оба сервера, чтобы студенты видели процесс.
\* **Терминал 1 (Бэкенд):** `cd` в папку с FastAPI проектом, команда: `uvicorn app.main:app --reload`. Показать в браузере `http://127.0.0.1:8000/docs`, чтобы убедиться, что API работает.
\* **Терминал 2 (Фронтенд):** `cd` в папку с React проектом, команда: `npm run dev`. Показать в браузере `http://localhost:5173`, чтобы убедиться, что сайт открывается.
1.2. **Формулировка цели:** Четко объявить: "Сейчас наш React-сайт берет данные из файла `data.ts`. Наша цель — заставить его загружать товары по сети, делая реальный запрос к нашему Python-серверу на порту 8000".

******

### **2. Первый запрос и первая ошибка: CORS**

2.1. **Задача для Инженера Кода:** Отредактировать файл `src/components/ProductsPage.tsx`.
\* **Шаг 1:** Закомментировать или удалить строку импорта статичных данных: `// import { products } from '../data/products';`
\* **Шаг 2:** Использовать хуки `useState` и `useEffect` для загрузки данных.
\`\`\`tsx
// src/components/ProductsPage.tsx
import { useState, useEffect } from 'react';
// ... импорт ProductCard и типа Product

````
  export function ProductsPage() {
    const [products, setProducts] = useState([]); // Начальное состояние - пустой массив
    const [searchQuery, setSearchQuery] = useState('');
  
    useEffect(() => {
      // Функция для загрузки данных
      const fetchProducts = async () => {
        console.log('Попытка загрузить данные с бэкенда...');
        try {
          const response = await fetch('http://127.0.0.1:8000/products');
          const data = await response.json();
          setProducts(data);
          console.log('Данные успешно загружены!', data);
        } catch (error) {
          console.error('Ошибка при загрузке данных:', error);
        }
      };
  
      fetchProducts();
    }, []); // Пустой массив зависимостей, чтобы хук сработал один раз при монтировании
  
    // ... остальной код компонента ...
  }
  ```
````

******
2.2. **Демонстрация ошибки:** Педагог должен сохранить файл, перейти в браузер на страницу React-приложения и открыть консоль разработчика (F12). Наглядно показать:
\* Страница пуста, товары не отображаются.
\* В консоли горит **красная ошибка**, содержащая текст: `Access to fetch at 'http://127.0.0.1:8000/products' from origin 'http://localhost:5173' has been blocked by CORS policy...`.
******

### **3. Объяснение CORS: "Политика одного источника"**

3.1. **Аналогия:** Использовать простую и понятную аналогию. "Представьте, что вы залогинены на сайте своего банка `mybank.com`. Затем вы открываете в другой вкладке вредоносный сайт `evil.com`. Без политики CORS, скрипт с сайта `evil.com` мог бы отправить запрос `mybank.com/api/transfer?to=hacker&amount=1000`. Ваш браузер, видя, что вы залогинены в банке, приложил бы к этому запросу ваши куки, и деньги бы ушли. Политика CORS запрещает это. Браузер блокирует запрос от `evil.com` к `mybank.com` по умолчанию".
3.2. **Вывод:** "Наши два приложения — `localhost:5173` (React) и `localhost:8000` (FastAPI) — для браузера являются двумя разными 'источниками' (origins). Чтобы наш 'хороший' запрос прошел, сервер `:8000` должен явно сказать браузеру: 'Я разрешаю принимать запросы от `:5173`, ему можно доверять'".

******

### **4. Решение: Настройка `CORSMiddleware` в FastAPI**

4.1. **Концепция:** Объяснить, что `Middleware` — это специальный обработчик, который "перехватывает" каждый запрос на пути к эндпоинту и каждый ответ на пути к клиенту. `CORSMiddleware` добавляет к ответам специальные HTTP-заголовки (`Access-Control-Allow-Origin`), которые и являются разрешением для браузера.
4.2. **Задача для Инженера Кода:** Отредактировать `app/main.py`.
\`\`\`python
\# app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware \# 1. Импортируем

````
app = FastAPI()

# 2. Определяем список разрешенных источников
origins = [
    "http://localhost:5173",
    # Можно добавить URL вашего фронтенда в продакшене
]

# 3. Добавляем Middleware в приложение
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins, # Разрешить запросы от этих источников
    allow_credentials=True, # Разрешить передачу кук
    allow_methods=["*"],    # Разрешить все методы (GET, POST, etc.)
    allow_headers=["*"],    # Разрешить все заголовки
)

# ... остальной код (app.include_router и т.д.)
```
````

4.3. **Объяснение для Педагога:** Подчеркнуть, что `allow_origins` — это белый список. В продакшене туда нужно будет добавить доменное имя фронтенд-приложения.

******

### **5. Практика: Оживляем каталог товаров**

5.1. **"Момент истины":**
\* Убедиться, что `uvicorn` перезапустился после сохранения `main.py`.
\* Вернуться во вкладку с React-приложением.
\* **Просто обновить страницу (F5).**
5.2. **Демонстрация результата:** Педагог должен показать три вещи:
\* Ошибка CORS в консоли исчезла.
\* Появилось сообщение `Данные успешно загружены!` с массивом товаров из базы данных.
\* **Главное:** На странице появились карточки товаров, отрисованные на основе данных, полученных с бэкенда. Полный цикл `БД -> SQLAlchemy -> FastAPI -> HTTP -> React -> HTML` замкнулся.
5.3. **Связь с домашним заданием:** "Мы оживили главную страницу каталога. Ваша задача — сделать то же самое для страницы детального просмотра товара (`ProductDetailPage.tsx`). Вам нужно будет получить ID товара из URL с помощью хука `useParams` из `react-router-dom`, сделать `fetch`-запрос на эндпоинт `/products/{ID}` и отобразить данные о конкретном товаре".

******

## Урок 7: Регистрация пользователей и безопасность: Хранение паролей

### **1. Проектирование сущности "Пользователь"**

1.1. **Задача для Инженера Кода:** Дополнить файл `app/models.py` новой SQLAlchemy-моделью.
\`\`\`python
\# app/models.py
from sqlalchemy import Boolean

````
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(150), unique=True, index=True)
    hashed_password: Mapped[str]
    is_active: Mapped[bool] = mapped_column(default=True)
```
````

******
1.2. **Объяснение для Педагога:** Акцентировать внимание на полях:
\* `email`: Будет использоваться как логин. `unique=True` — это constraint на уровне БД, который не позволит создать двух пользователей с одинаковым email.
\* `hashed_password`: Подчеркнуть, что мы **никогда** не будем хранить здесь пароль в открытом виде, только его хэш.
1.3. **Процесс миграции:** Напомнить студентам, что после добавления новой модели в код, необходимо синхронизировать БД.
\* **Шаг 1:** `alembic revision --autogenerate -m "Create users table"`
\* **Шаг 2:** `alembic upgrade head`
******

### **2. "Золотое правило безопасности": Никогда не храните пароли в открытом виде\!**

2.1. **Аналогия:** Использовать аналогию с банковской картой. "Хранить пароль в базе данных в виде простого текста — это как написать PIN-код маркером прямо на карте. Если вор украдет кошелек (взломает БД), он получит сразу всё. Наша задача — сделать так, чтобы даже украв карту, вор не смог узнать PIN-код".
2.2. **Последствия:** Описать, что утечка паролей ведет к компрометации пользователей на других сервисах (т.к. люди часто используют одинаковые пароли) и к огромным репутационным потерям для компании.
******

### **3. Решение: Хэширование паролей с `passlib`**

3.1. **Концепция (Аналогия "Мясорубка"):** "Хэширование — это как необратимая мясорубка. Вы можете положить в нее кусок мяса (пароль) и получить фарш (хэш). Но вы никогда не сможете засунуть фарш обратно и получить исходный кусок мяса. Это односторонняя операция".
3.2. **Задача для Инженера Кода:**
\* **Шаг 1: Установка.** `pip install "passlib[bcrypt]"` (bcrypt — это надежный и популярный алгоритм хэширования).
\* **Шаг 2: Создать `app/security.py`**. Вынести всю логику работы с паролями в отдельный файл.
\`\`\`python
\# app/security.py
from passlib.context import CryptContext

````
  # 1. Создаем контекст, указывая схему хэширования
  pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
  
  # 2. Функция для проверки пароля
  def verify_password(plain_password, hashed_password):
      return pwd_context.verify(plain_password, hashed_password)
      
  # 3. Функция для получения хэша пароля
  def get_password_hash(password):
      return pwd_context.hash(password)
  ```
````

******
3.3. **Объяснение для Педагога:** Объяснить, что при проверке пароля мы не "расшифровываем" хэш. Мы берем пароль, который ввел пользователь, хэшируем его и **сравниваем два хэша**. `passlib` делает это безопасно.
******

### **4. Практика: Реализуем эндпоинт регистрации**

4.1. **Задача для Инженера Кода: Схемы (`app/schemas.py`).** Создать Pydantic-схемы для пользователя, чтобы не передавать пароль в ответах API.
\`\`\`python
from pydantic import BaseModel, EmailStr

````
class UserBase(BaseModel):
    email: EmailStr

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True # Для преобразования из SQLAlchemy-модели
```
````

******
4.2. **Задача для Инженера Кода: CRUD (`app/crud.py`).** Добавить функцию создания пользователя.
\`\`\`python
from . import models, schemas, security

````
async def create_user(db: AsyncSession, user: schemas.UserCreate):
    # Проверка на существующего пользователя (очень важно!)
    existing_user = await get_user_by_email(db, user.email)
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Хэшируем пароль перед сохранением
    hashed_password = security.get_password_hash(user.password)
    db_user = models.User(email=user.email, hashed_password=hashed_password)
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user
```
````

******
4.3. **Задача для Инженера Кода: Роутер (`app/routers/users.py`).** Создать новый файл для эндпоинтов пользователей.
\`\`\`python
from fastapi import APIRouter, Depends
\# ... импорты ...

````
router = APIRouter(prefix="/users", tags=["Users"])

@router.post("/", response_model=schemas.User)
async def create_user_endpoint(user: schemas.UserCreate, db: AsyncSession = Depends(get_db_session)):
    return await crud.create_user(db=db, user=user)
```
````

******
4.4. **Завершающий шаг:** Не забыть подключить новый роутер в `app/main.py`: `app.include_router(users.router)`.
4.5. **Демонстрация:** Через `/docs` создать нового пользователя. Затем с помощью GUI-клиента для БД **показать** студентам таблицу `users` и содержимое колонки `hashed_password`. Там должна быть длинная абракадабра, а не тот пароль, что был введен. Это и есть доказательство, что все работает правильно.
4.6. **Связь с домашним заданием:** "Мы реализовали бэкенд для регистрации. Ваша задача — создать в React-приложении страницу регистрации с формой (поля email и password) и 'подключить' ее к нашему новому эндпоинту `POST /users/`".

******

## Урока 8: Аутентификация и JWT-токены - безопасный вход пользователей

### **1. Проблема: HTTP "без памяти"**

1.1. **Аналогия "Контролер в автобусе":** "Представьте, что HTTP — это контролер с амнезией. Вы заходите, показываете ему билет (логин/пароль). Он вас пропускает. Через 5 минут он подходит к вам снова и спрашивает билет, потому что совершенно вас не помнит. Носить с собой и каждый раз показывать билет — неудобно. Гораздо лучше получить у водителя 'проездной' (токен), который действителен всю поездку и который легко предъявить".
1.2. **Технический вывод:** Нам нужен механизм, который позволит клиенту (React-приложению) при каждом запросе к защищенным ресурсам быстро доказывать серверу, что он уже прошел проверку.
******
1.3. **Варианты решения:** Куки, сессии, OAuth, JWT. Объяснить, что мы выберем JWT (JSON Web Tokens) из-за его простоты и популярности в современных SPA-приложениях. (Детально рассказать про JWT)
******

### **2. Решение: JWT-токены**

2.1. **Установка зависимостей (Задача для Инженера Кода):**
\* `pip install python-jose[cryptography]` — для создания и проверки JWT.
\* `pip install python-multipart` — для приема данных из HTML-форм, что понадобится для `OAuth2PasswordRequestForm`.
2.2. **Аналогия "Цифровой пропуск":** Детально разобрать структуру.
\* **Payload (Данные):** "Это то, что написано на пропуске: `sub: 'user@example.com'` (субъект, кому выдан), `exp: 1678886400` (expiration, до какого времени действителен)".
\* **Signature (Подпись):** "Самое важное. Это 'голограмма' на пропуске, созданная с помощью секретного ключа, который есть только у сервера. Если кто-то скопирует ваш пропуск и попытается вписать в него чужое имя, голограмма повредится, и охрана (сервер) это немедленно обнаружит".
******
2.3. **Настройка (Задача для Инженера Кода):** Добавить секретный ключ и параметры токена в `app/config.py`.
\`\`\`python
\# app/config.py
import os

````
# Генерируется командой: openssl rand -hex 32
SECRET_KEY = os.getenv("SECRET_KEY", "your_default_super_secret_key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
```
* **Объяснение для Педагога:** Подчеркнуть, что в реальном проекте `SECRET_KEY` **обязательно** должен загружаться из переменных окружения, а не храниться в коде.
````

******
2.4. **Создание JWT-утилиты (Задача для Инженера Кода):** Дополнить `app/security.py` функцией создания токена.
\`\`\`python
\# app/security.py
from datetime import datetime, timedelta, timezone
from jose import jwt
from app.config import SECRET\_KEY, ALGORITHM

````
def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        # Если время жизни не передано, ставим 15 минут
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```
````

******

### **3. Логика входа и `OAuth2PasswordRequestForm`**

3.1. **Концепция:** Объяснить, что мы будем использовать стандартный для веб-фреймворков механизм `OAuth2PasswordRequestForm`. Он ожидает, что клиент отправит `POST`-запрос с данными в формате `x-www-form-urlencoded`, содержащими два поля: `username` и `password`.
3.2. **Функция аутентификации (Задача для Инженера Кода):** Добавить в `app/crud.py` функцию-помощник для проверки пользователя.
\`\`\`python
\# app/crud.py
from . import security

````
async def authenticate_user(db: AsyncSession, email: str, password: str):
    user = await get_user_by_email(db, email=email)
    if not user:
        return None
    if not security.verify_password(password, user.hashed_password):
        return None
    return user
```
````

******

### **4. Практика: Создаем эндпоинт для логина**

4.1. **Задача для Инженера Кода:** Создать новый роутер `app/routers/auth.py` и эндпоинт в нем.
\`\`\`python
\# app/routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from datetime import timedelta
from app import crud, security, schemas
from app.config import ACCESS\_TOKEN\_EXPIRE\_MINUTES

````
router = APIRouter(tags=["Authentication"])

@router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db_session)
):
    user = await crud.authenticate_user(db, email=form_data.username, password=form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}
```
* Понадобится также добавить Pydantic-схему `Token` в `schemas.py`.
````

******
4.2. **Подключение роутера:** Напомнить о необходимости добавить `app.include_router(auth.router)` в `app/main.py`.
4.3. **Демонстрация:**
\* Открыть `/docs`. Появится новый эндпоинт `/token`.
\* Использовать форму, ввести `email` (в поле `username`) и `password` зарегистрированного пользователя.
\* Показать успешный ответ с `access_token`.
\* **Ключевой момент:** Показать кнопку **Authorize** в правом верхнем углу Swagger UI. Нажать на нее, вставить полученный токен и закрыть. Объяснить, что теперь Swagger будет "предъявлять этот пропуск" при каждом запросе к другим эндпоинтам.
4.4. **Связь с домашним заданием:** "Мы научили бэкенд выдавать 'пропуска'. Ваша задача — реализовать в React-приложении форму входа. После отправки формы и получения успешного ответа от эндпоинта `/token`, вы должны сохранить полученный `access_token` в `localStorage` браузера, чтобы он был готов к использованию на следующем уроке".

******

## Урок 9: Защита эндпоинтов приватными маршрутами с JWT

### **1. Концепция: Публичные и приватные эндпоинты**

1.1. **Аналогия "Ночной клуб":** "Наш API — это клуб. Вход в 'общий зал' (например, `GET /products`) свободный для всех. Но есть 'VIP-зона' (например, `GET /users/me` — получить данные о себе), куда пускают только по специальным браслетам (нашим JWT-токенам). Сегодня мы ставим на входе в VIP-зону 'охранника', который будет проверять эти браслеты".
1.2. **Цель:** Создать универсальный механизм ("охранника"), который можно будет легко "поставить" перед любым эндпоинтом, чтобы сделать его приватным.

******

### **2. Схема `OAuth2PasswordBearer`**

2.1. **Концепция:** Это не сам "охранник", а его главный инструмент — **сканер**. `OAuth2PasswordBearer` — это класс-помощник, который умеет делать только одну вещь: искать в заголовках запроса `Authorization` и извлекать оттуда токен (`Bearer eyJhbGci...`). Если он не находит заголовок или токен, он немедленно разворачивает клиента с ошибкой `401 Unauthorized`.
2.2. **Задача для Инженера Кода:** Создать экземпляр этого "сканера" в `app/security.py`.
\`\`\`python
\# app/security.py
from fastapi.security import OAuth2PasswordBearer

````
# tokenUrl указывает на эндпоинт, который выдает токен
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token")
```
````

******

### **3. Логика проверки токена**

3.1. **Концепция:** Наш "охранник" должен быть умным. Получив токен от "сканера", он должен провести полную проверку:
\* Это не подделка? (Проверить цифровую подпись).
\* Он не просрочен? (Проверить поле `exp`).
\* Человек, которому выдан пропуск, все еще числится в нашей базе? (Проверить наличие пользователя в БД).

******

3.2. **Задача для Инженера Кода: Дополнить `app/schemas.py`**. Создать Pydantic-схему для данных внутри токена.
` python # app/schemas.py class TokenData(BaseModel): email: str | None = None `
3.3. **Задача для Инженера Кода: Написать функцию-зависимость.** Это и есть наш "охранник". Добавить в `app/security.py`.
\`\`\`python
\# app/security.py
from fastapi import Depends, HTTPException, status
from jose import JWTError
\# ... импорты crud, models, schemas, database, config ...

````
async def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db_session)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # 1. Декодируем. jose сама проверит подпись и срок действия.
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = schemas.TokenData(email=email)
    except JWTError:
        raise credentials_exception
    
    # 2. Ищем пользователя в БД.
    user = await crud.get_user_by_email(db, email=token_data.email)
    if user is None:
        raise credentials_exception
    
    # 3. Возвращаем модель пользователя.
    return user
```
````

******

### **4. Практика: Создаем зависимость `get_current_user` и защищаем эндпоинт**

4.1. **Цель:** Показать, насколько легко теперь сделать любой эндпоинт приватным.
4.2. **Задача для Инженера Кода:** Создать новый эндпоинт в `app/routers/users.py`.
\`\`\`python
\# app/routers/users.py
from .. import security, models
\# ...

````
@router.get("/me", response_model=schemas.User)
async def read_users_me(current_user: models.User = Depends(security.get_current_user)):
    # Если код дошел до этой строчки, значит, пользователь успешно аутентифицирован.
    # В переменной current_user находится полная модель пользователя из БД.
    return current_user
```
````

******
4.3. **Объяснение для Педагога:** Сделать акцент на `Depends(security.get_current_user)`. Этой одной строчкой мы "ставим нашего охранника" на входе в эндпоинт. Вся сложная логика проверки происходит "за кулисами".
4.4. **Демонстрация (в `/docs`):**
\* **Попытка 1 (без "пропуска"):** Убедиться, что в Swagger UI не вставлен токен (кнопка "Authorize" разблокирована). Зайти на `GET /users/me` и нажать "Execute". Показать результат — ошибка `401 Unauthorized` "Not authenticated".
\* **Попытка 2 (с "пропуском"):**
1\. Сходить на эндпоинт `/token`, залогиниться и скопировать `access_token`.
2\. Нажать "Authorize", вставить токен в формате `Bearer <token>`.
3\. Вернуться к `GET /users/me` и снова нажать "Execute".
4\. Показать результат — успешный ответ `200 OK` с данными того пользователя, от имени которого был получен токен.
4.5. **Связь с домашним заданием:** "Мы научились защищать бэкенд. Ваша задача — научить фронтенд 'предъявлять пропуск'. В React-компоненте `ProfilePage.tsx` сделайте запрос к `/users/me`. Вам нужно будет прочитать токен из `localStorage` и добавить его в заголовок `Authorization` при `fetch`-запросе. Отобразите email полученного пользователя на странице".

******

## Урока 10: Реализация корзины на сервере

### **1. Проблема: Почему клиентская корзина — это плохо?**

1.1. **Анализ кода:** Педагог должен открыть файл `src/hooks/useCart.tsx` и показать студентам, что вся логика основана на `useState`. Это `items`, которые хранятся только в памяти браузера.
1.2. **Практическая демонстрация:**
\* **Сценарий А:** Добавить 2-3 товара в корзину в приложении. Затем открыть это же приложение в другом браузере (или в режиме "инкогнито"). **Результат:** Корзина пуста. Вывод: **состояние не синхронизировано между устройствами/браузерами**.
\* **Сценарий Б:** Снова добавить товары. Открыть консоль разработчика -\> Application -\> Local Storage / Session Storage -\> Clear all. Обновить страницу. **Результат:** Корзина пуста. Вывод: **состояние не постоянно и легко теряется**.
1.3. **Итог:** Для любого серьезного e-commerce проекта необходимо хранить корзину на сервере и связывать её с учетной записью пользователя.

******

### **2. Проектирование моделей данных для корзины**

2.1. **Концепция:** Обсудить, как смоделировать эти отношения. Пользователь (`User`) имеет одну Корзину (`Cart`). Корзина (`Cart`) имеет много Позиций в корзине (`CartItem`). Каждая Позиция (`CartItem`) ссылается на один Товар (`Product`) и хранит его количество.
2.2. **Задача для Инженера Кода:** Дополнить `app/models.py` новыми моделями и связями.
\`\`\`python
\# app/models.py
\# ...
class Cart(Base):
**tablename** = "carts"
id: Mapped[int] = mapped\_column(primary\_key=True)
user\_id: Mapped[int] = mapped\_column(ForeignKey("users.id"), unique=True)
\# Связь "один-к-одному" с пользователем
user: Mapped["User"] = relationship(back\_populates="cart")
\# Связь "один-ко-многим" с позициями в корзине
items: Mapped[list["CartItem"]] = relationship(cascade="all, delete-orphan")

````
class CartItem(Base):
    __tablename__ = "cart_items"
    id: Mapped[int] = mapped_column(primary_key=True)
    cart_id: Mapped[int] = mapped_column(ForeignKey("carts.id"))
    product_id: Mapped[int] = mapped_column(ForeignKey("products.id"))
    quantity: Mapped[int] = mapped_column(default=1)

# В модели User добавить обратную связь
class User(Base):
    # ...
    cart: Mapped["Cart" | None] = relationship(back_populates="user", cascade="all, delete-orphan")
```
````

2.3. **Миграция:** Напомнить студентам о необходимости выполнить `alembic revision --autogenerate -m "Add cart models"` и `alembic upgrade head`.
******

### **3. Реализация защищенных эндпоинтов**

3.1. **Ключевая идея:** Все операции с корзиной должны знать, *для какого пользователя* они выполняются. Поэтому каждый эндпоинт будет защищен зависимостью `Depends(security.get_current_user)`.
3.2. **Задача для Инженера Кода:**
\* В `schemas.py` создать Pydantic-схемы для `Cart` и `CartItem`.
\* В `crud.py` написать функции: `get_or_create_cart_by_user_id`, `add_product_to_cart`, `remove_product_from_cart`.
\* Создать новый роутер `app/routers/cart.py`.
\`\`\`python
\# app/routers/cart.py
from fastapi import APIRouter, Depends
\# ... импорты ...

````
  router = APIRouter(prefix="/cart", tags=["Cart"])

  @router.get("/", response_model=schemas.Cart)
  async def get_my_cart(current_user: models.User = Depends(security.get_current_user), db: AsyncSession = Depends(get_db_session)):
      return await crud.get_or_create_cart(db, user_id=current_user.id)

  @router.post("/items", response_model=schemas.Cart)
  async def add_item_to_my_cart(
      item_data: schemas.CartItemCreate,
      current_user: models.User = Depends(security.get_current_user),
      db: AsyncSession = Depends(get_db_session)
  ):
      return await crud.add_item_to_cart(db, user_id=current_user.id, item=item_data)
  
  # ... и эндпоинт для удаления ...
  ```
````

3.3. **Подключение роутера:** Не забыть добавить `app.include_router(cart.router)` в `main.py`.
******

### **4. Интеграция с React: Рефакторинг хука `useCart`**

4.1. **Цель:** Заменить локальное управление состоянием на асинхронные API-вызовы.
4.2. **Задача для Инженера Кода:** Переписать `src/hooks/useCart.tsx`.
\* Вместо инициализации `useState([])`, создать `useEffect`, который при монтировании (и при логине/логауте) делает `fetch`-запрос к `GET /cart` и наполняет состояние.
\* Функция `addToCart` теперь должна делать `POST`-запрос к `/cart/items`, передавая ID товара и количество. В заголовках запроса **обязательно** должен быть `Authorization: Bearer <token>`.
\* Функция `removeFromCart` делает `DELETE`-запрос.
\* После каждого успешного изменения (добавления/удаления) нужно заново запрашивать состояние корзины с бэкенда, чтобы синхронизировать данные.
******

4.3. **Демонстрация ("Момент истины"):**
\* Залогиниться в React-приложении.
\* Добавить товар в корзину. В консоли разработчика показать уходящий `POST`-запрос с токеном.
\* С помощью GUI-клиента для БД показать, что в таблицах `carts` и `cart_items` появились новые записи, связанные с ID залогиненного пользователя.
\* Выйти из системы и зайти снова. **Результат:** Корзина не пуста, она загрузилась с сервера.
\* Зайти под тем же пользователем в другом браузере. **Результат:** Корзина та же самая. Проблема решена.
4.4. **Связь с домашним заданием:** "Мы реализовали серверную корзину. Ваша задача — полностью доделать интеграцию. Подключите удаление товаров из корзины и, что важнее, реализуйте логику обновления количества товара (например, через `PUT /cart/items/{item_id}`), чтобы пользователь мог менять число товаров прямо в корзине".

******

## Урок 11: Финал — развертывание с Docker и Docker Compose

### **1. Проблема: "У меня на машине все работало\!"**

1.1. **Сценарий:** Рассказать студентам типичную историю. "Вы закончили проект, он идеально работает на вашем ноутбуке. Вы отправляете его другу. Друг запускает и получает ошибку `ModuleNotFoundError` или `OperationalError: connection refused`. Почему? Он забыл установить одну библиотеку, или у него другая версия PostgreSQL, или он неправильно назвал базу данных при создании".
1.2. **Вывод:** Развертывание — это хаос из-за различий в окружении. Нам нужен способ поставлять не только код, но и **всё окружение целиком**: нужную версию Python, все библиотеки и настроенную базу данных.
******

### **2. Решение: Docker — универсальный "контейнер" для приложения**

2.1. **Аналогия "Морской контейнер":** "Docker — это технология, которая позволяет упаковать ваше приложение и все его зависимости в один стандартный 'контейнер' (образ). Этот контейнер можно запустить на любом компьютере, где установлен Docker, и он будет работать абсолютно так же. Мы больше не доставляем 'мебель' (код), мы доставляем 'комнату с мебелью' (образ с кодом и окружением)".
2.2. **Образ vs. Контейнер:** Четко разграничить понятия:
\* **Образ (Image):** Это чертеж, шаблон, "слепок" системы. Он не запущен.
\* **Контейнер (Container):** Это работающий, живой экземпляр образа. Из одного образа можно запустить много одинаковых контейнеров.
******

### **3. `Dockerfile`: Инструкция по сборке нашего "контейнера"**

3.1. **Подготовка (Задача для Инженера Кода):** Создать файл `requirements.txt`. В терминале, с активированным виртуальным окружением, выполнить команду: `pip freeze > requirements.txt`.
3.2. **Создание `Dockerfile` (Задача для Инженера Кода):** В корне проекта создать файл `Dockerfile` (без расширения).
\`\`\`dockerfile
\# Шаг 1: Базовый образ. Берем официальный Python 3.11 в "легкой" версии.
FROM python:3.11-slim

````
# Шаг 2: Устанавливаем рабочую папку внутри контейнера.
WORKDIR /app

# Шаг 3: Копируем зависимости и устанавливаем их.
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Шаг 4: Копируем весь код нашего приложения.
COPY . .

# Шаг 5: Команда для запуска приложения при старте контейнера.
# Uvicorn будет слушать на всех интерфейсах (0.0.0.0) внутри контейнера.
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```
````

3.3. **Объяснение для Педагога:** Разобрать каждую команду: `FROM`, `WORKDIR`, `COPY`, `RUN`, `CMD`. Особое внимание уделить `--host 0.0.0.0` — без этого сервер будет недоступен извне контейнера.
******

### **4. `docker-compose`: Дирижер для нашего оркестра**

4.1. **Концепция:** Наше приложение состоит из двух частей: API и база данных. `docker-compose` позволяет описать в одном файле все части системы и их взаимодействие, а затем запустить или остановить их одной командой.
4.2. **Создание `docker-compose.yml` (Задача для Инженера Кода):** В корне проекта создать файл `docker-compose.yml`.
\`\`\`yaml
version: '3.8'

````
services:
  # Наш FastAPI сервис
  api:
    build: . # Инструкция: собери образ из Dockerfile в текущей папке
    ports:
      - "8008:8000" # Пробрось порт 8000 из контейнера на порт 8008 на моем компьютере
    environment:
      # Передаем переменные окружения в наше приложение
      - DATABASE_URL=postgresql+asyncpg://postgres:mysecretpassword@db:5432/store_db
      - SECRET_KEY=a_very_secret_key_for_docker
    depends_on:
      - db # Запускай API только после того, как запустится сервис 'db'
  
  # Сервис базы данных PostgreSQL
  db:
    image: postgres:15-alpine # Используй готовый официальный образ
    volumes:
      - postgres_data:/var/lib/postgresql/data/ # Сохраняй данные из этой папки в томе postgres_data
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=mysecretpassword
      - POSTGRES_DB=store_db

volumes:
  # Определяем том для сохранения данных БД
  postgres_data:
```
````

4.3. **Объяснение для Педагога:** Объяснить ключевые моменты: `build` vs `image`, `ports`, `environment` (и почему хост теперь `db`), `volumes` (для сохранения данных) и `depends_on`.
******

### **5. Практика: Запускаем всю систему одной командой**

5.1. **"Момент истины" (Задача для Инженера Кода):** Попросить студентов выполнить в терминале всего одну команду:
` bash docker-compose up --build `
5.2. **Демонстрация:** Показать лог в терминале: Docker скачивает образ `postgres`, собирает образ `api` по шагам из `Dockerfile`, запускает оба контейнера.
******
5.3. **Проверка:**
\* Открыть браузер и перейти на **`http://localhost:8008/docs`**. API должно работать.
\* Выполнить в терминале `docker-compose down` (остановить и удалить контейнеры).
\* Снова выполнить `docker-compose up`.
\* **Важно:** Показать, что данные, созданные ранее (например, пользователи), **остались на месте**, так как они хранятся в `volume`.
5.4. **Связь с домашним заданием:** "Мы 'упаковали' наше приложение. Ваше финальное задание — полностью воспроизвести этот процесс. Создайте `Dockerfile` и `docker-compose.yml`, запустите проект. Убедитесь, что ваше React-приложение может общаться с докеризированным бэкендом (не забудьте поменять URL на `localhost:8008`) и что весь функционал работает. Поздравляю, вы прошли путь от идеи до готового к развертыванию full-stack приложения\!"
